# -*- coding: utf-8 -*-
"""OperatingSystemProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_h6iAHoq_-WZ-0-ddKPu3uC_yB-7_6R2

# Operating System Project
"""

# @title Master function

available_functions = {
    "1": main_function_1,
    "2": main_function_2,
    "3": main_function_3,
    "4": main_function_4,
    "5": main_function_5
}

# Ask the user to choose a function to run
selected_function = input("Enter the number from the menu: \n1- Priority\n2- Perimitive SJF\n3- Round Robin\n4- Non-Primitive SJF\n5- First Come, First Served (FCFS)\n")

# Execute the selected function
if selected_function in available_functions:
    available_functions[selected_function]()
else:
    print("Invalid selection. Please choose a number between 1 and 5.")

# @title priority
import matplotlib.pyplot as plt
from tabulate import tabulate

# Priority Ø®ÙˆØ±Ø§Ø²Ù…ÙŠØ©
def priority_scheduling(processes):
    #ØªÙ†Ø¸ÙŠÙ… Ø¹Ù„Ù‰ Ø§Ø³Ø§Ø³ Ø§Ù„Ø§ÙˆÙ„ÙˆÙŠØ©
    processes.sort(key=lambda x: x['priority'])

    print("\nProcess Execution Order based on Priority Scheduling:")
    total_wait_time = 0
    total_turnaround_time = 0
    time_elapsed = 0

    process_table = []  # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§ Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø¬Ø¯ÙˆÙ„

    process_names = []
    start_times = []
    burst_times = []
    turnaround_times = []

    for process in processes:
        # Ø­Ø³Ø§Ø¨ wait time Ùˆ turnaround time
        wait_time = time_elapsed
        turnaround_time = wait_time + process['burst_time']

        total_wait_time += wait_time
        total_turnaround_time += turnaround_time

        # ØªÙˆØµÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨Ø±ÙˆØ³ÙŠØ³ Ø§Ù„Ù‰ Ø§Ù„Ø¬Ø¯ÙˆÙ„
        process_table.append([process['name'], process['burst_time'], wait_time, turnaround_time])

        # ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ…Ø±
        process_names.append(process['name'])
        start_times.append(time_elapsed)
        burst_times.append(process['burst_time'])
        turnaround_times.append(turnaround_time)
        time_elapsed += process['burst_time']

    avg_wait_time = total_wait_time / len(processes)
    avg_turnaround_time = total_turnaround_time / len(processes)

    # Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø¬Ø¯ÙˆÙ„
    print(tabulate(process_table, headers=["ğŸ”¤ Process", "â²ï¸ Burst Time   ", "â±ï¸ Waiting Time   ", "â³ Turnaround Time   "], tablefmt="grid"))
    print(f"\nğŸ•’ Average Waiting Time: {avg_wait_time:.2f}")
    print(f"â³ Average Turnaround Time: {avg_turnaround_time:.2f}")

    # ØªØµÙˆÙŠØ± Ø§Ù„Ø¨Ø±ÙˆØ³ÙŠØ³ Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Gantt-Chart
    plt.figure(figsize=(14, 2))

    # Ø¹Ø±Ø¶ Gantt-Chart
    for i, process in enumerate(process_names):
        plt.barh(0.4, burst_times[i], left=start_times[i], color='lightblue', edgecolor='black', height=0.8)
        plt.text(start_times[i] + burst_times[i] / 2, 0.4, process, ha='center', va='center', color='black', fontsize=30)
    # Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙˆÙ‚Øª ÙÙŠ Ø§Ù„Ø´ÙƒÙ„
    for start, burst in zip(start_times, burst_times):
        plt.text(start, -0.2, f"{start}", ha='center', va='center', fontsize=25)
    plt.text(start_times[-1] + burst_times[-1], -0.2, f"{start_times[-1] + burst_times[-1]}", ha='center', va='center', fontsize=25)

    plt.yticks([])
    plt.xticks([])
    plt.title('Gantt Chart - Priority Scheduling')
    plt.tight_layout()
    plt.show()

# Main function
def main_function_1():
    print("Running main function 1")

    processes = []
    num_processes = int(input(" \"â­ priority scheduling Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø§ÙˆÙ„ÙˆÙŠØ© â­\" \n \n Enter the number of processes: "))

    for i in range(num_processes):
        name = f"P{i + 1}"
        print(f"\nProcess {name}:")
        priority = int(input(f"ğŸ”¢ Enter priority : "))
        burst_time = int(input(f"â²ï¸ Enter burst time : "))
        processes.append({'name': name, 'priority': priority, 'burst_time': burst_time})

    priority_scheduling(processes)

# @title primitive SJF

import matplotlib.pyplot as plt

# === Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© SJF Preemptive (SRTF) Ù…Ø®ØªØµØ±Ø© ===

def srtf(at, bt):
    n = len(bt) # Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª


    rt = bt.copy() # # rt = ÙˆÙ‚Øª Ø§Ù„ØªÙ†ÙÙŠØ° Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ù„ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ©
    wt = [0]*n # Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± (Waiting Time)

    tat = [0]*n # Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ø¯ÙˆØ±Ø§Ù† (Turnaround Time)

    rt_time = [-1]*n  # ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© (Response Time)

    gantt = []  # Ù„ØªØ®Ø²ÙŠÙ† Ù…Ø®Ø·Ø· Ø¬Ø§Ù†Øª
    t = complete = 0 ## t = Ø§Ù„Ø²Ù…Ù† Ø§Ù„Ø­Ø§Ù„ÙŠØŒ complete = Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù…Ù†ØªÙ‡ÙŠØ©

    while complete < n:
        ready = [i for i in range(n) if at[i] <= t and rt[i] > 0]  # Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¹Ù…Ù„ÙŠÙ‡ Ø¬Ø§Ù‡Ø²Ù‡ Ù„Ù„ØªÙ†ÙÙŠØ°

        if not ready:# Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ÙŠ Ù…Ùˆ Ø¬Ø§Ù‡Ø²Ø©
            gantt.append("Idle")
            t += 1 # Ù†Ø²ÙŠØ¯ Ø§Ù„ÙˆÙ‚Øª 1 ÙˆÙ†ÙƒÙ…Ù„
            continue

        j = min(ready, key=lambda i: rt[i]) # ÙŠØ®ØªØ§Ø± Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø¬Ø§Ù‡Ø²Ø© Ø§Ù„ÙŠ Ø¨Ø§Ù‚ÙŠ ÙÙŠÙ‡Ø§  Ø£Ù‚Ù„ ÙˆÙ‚Øª ØªÙ†ÙÙŠØ° Ù…ØªØ¨Ù‚ÙŠ
        if rt_time[j] < 0:# Ø¥Ø°Ø§ Ù‡Ø°Ù‡ Ø£ÙˆÙ„ Ù…Ø±Ø© ØªÙÙ†ÙØ° Ø§Ù„Ø¹Ù…Ù„ÙŠØ©ØŒ ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©

            rt_time[j] = t - at[j] # Ø¥Ø°Ø§ Ù‡Ø°Ù‡ Ø£ÙˆÙ„ Ù…Ø±Ø© ØªÙÙ†ÙØ° Ø§Ù„Ø¹Ù…Ù„ÙŠØ©ØŒ ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©

  # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©

        rt[j] -= 1 # Ù†Ù†Ù‚Øµ Ù…Ù† ÙˆÙ‚ØªÙ‡Ø§
        gantt.append(f"P{j+1}") # Ù†Ø¶ÙŠÙÙ‡Ø§ Ø§Ù„Ù‰ Ù…Ø®Ø·Ø· Ø¬Ø§Ù†Øª

        if rt[j] == 0:
            complete += 1
            finish = t + 1
            wt[j] = max(0, finish - bt[j] - at[j]) # Ø§Ø°Ø§ Ø§Ù†ØªÙ‡Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù†Ø­Ø³Ø¨ ÙˆÙ‚Øª Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±

            tat[j] = bt[j] + wt[j] # Ù†Ø­Ø³Ø¨ ÙˆÙ‚Øª Ø§Ù„Ø¯ÙˆØ±Ø§Ù†

        t += 1

    return wt, tat, rt_time, gantt

# === Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© ÙˆØ§Ù„Ø±Ø³Ù… ===
def main_function_2():
    n = int(input("Ø£Ø¯Ø®Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª: "))
    at = [int(input(f"ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„ P{i+1}: ")) for i in range(n)]
    bt = [int(input(f"ÙˆÙ‚Øª Ø§Ù„ØªÙ†ÙÙŠØ° P{i+1}: ")) for i in range(n)]

    wt, tat, rt_time, gantt = srtf(at, bt)

    # Ø¶ØºØ· Ø§Ù„ÙØªØ±Ø§Øª ÙÙŠ Ù…Ø®Ø·Ø· Ø¬Ø§Ù†Øª
    comp = []
    cur = gantt[0]; start = 0
    for i, g in enumerate(gantt[1:], 1):
        if g != cur:
            comp.append((cur, start, i))
            cur, start = g, i
    comp.append((cur, start, len(gantt)))

    # Ø±Ø³Ù… Ø§Ù„Ø¬Ø¯ÙˆÙ„
    fig, axs = plt.subplots(2, 1, figsize=(12, 5), gridspec_kw={'height_ratios': [1, 2]})
    axs[0].axis('off')
    cols = ['Process', 'Arrival', 'Burst', 'Waiting', 'Turnaround', 'Response']
    rows = [[f"P{i+1}", at[i], bt[i], wt[i], tat[i], rt_time[i]] for i in range(n)]
    axs[0].table(cellText=rows, colLabels=cols, loc='center').scale(1, 2)

    # Ø±Ø³Ù… Ø¬Ø§Ù†Øª
    for task, s, e in comp:
        axs[1].barh(0, e - s, left=s, edgecolor='black')
        axs[1].text((s + e) / 2, 0, task, va='center', ha='center', color='white', fontsize=9)

    axs[1].set(xlim=(0, len(gantt)), yticks=[], xticks=range(len(gantt)+1), title='Gantt Chart - SRTF')
    axs[1].grid(axis='x')
    plt.tight_layout()
    plt.show()

# @title Round Robin (RR)
import matplotlib.pyplot as plt
import pandas as pd

def main_function_3():
    print("Round Robin Scheduler")

    # Input # of processes and time quantum
    n = int(input("Enter number of processes: "))
    quantum = int(input("Enter Time Quantum: "))

    #Create process names and input their burst times
    processes = [f"P{i+1}" for i in range(n)]
    burst_times = [int(input(f"Burst Time for {p}: ")) for p in processes]

    # Initialize data structures
    remaining_bt = burst_times.copy()      # Remaining burst time for each process
    waiting = [0] * n                      # Waiting time for each process
    turnaround = [0] * n                   # Turnaround time for each process
    response = [-1] * n                    # Response time, initialized to -1 (not started yet)
    timeline = []                          # To store execution order and times for Gantt Chart
    current_time = 0                       # Current time in the schedule

    # RR execution loop
    while True:
        done = True # Assume all processes are done

        for i in range(n): # check
            if remaining_bt[i] > 0:
                done = False

                # If process is running for the first time => store its response time
                if response[i] == -1:
                    response[i] = current_time

                # Calculate start and end times for this execution slice
                start = current_time
                exec_time = min(quantum, remaining_bt[i])
                current_time += exec_time
                remaining_bt[i] -= exec_time
                end = current_time

                # Add this slice to the timeline for Gantt Chart
                timeline.append((processes[i], start, end))

                # If the process has finished, calculate turnaround and waiting time
                if remaining_bt[i] == 0:
                    turnaround[i] = current_time
                    waiting[i] = turnaround[i] - burst_times[i]
        if done:
            break

    # Display results in a table
    df = pd.DataFrame({
        "Process": processes,
        "Burst Time": burst_times,
        "Waiting Time": waiting,
        "Turnaround Time": turnaround,
        "Response Time": response
    })

    print("\n", df.to_string(index=False))

    # Print averages
    print(f"\nAverage Waiting Time   : {sum(waiting)/n:.2f}")
    print(f"Average Turnaround Time: {sum(turnaround)/n:.2f}")
    print(f"Average Response Time  : {sum(response)/n:.2f}")

    # Count context switches
    context_switches = max(0, len(timeline) - 1)



    print(f"Number of Context Switches: {context_switches}")

    # Draw Gantt Chart
    fig, ax = plt.subplots(figsize=(10, 2))
    for pid, start, end in timeline:
        ax.barh(0, end - start, left=start, color='skyblue', edgecolor='black')
        ax.text((start + end) / 2, 0, pid, ha='center', va='center')
        ax.text(start, 0.3, str(start), ha='center', fontsize=8)
        ax.text(end, 0.3, str(end), ha='center', fontsize=8)

    plt.title("Round Robin Scheduling - Gantt Chart")
    plt.xlabel("Time")
    plt.yticks([])
    plt.tight_layout()
    plt.show()

# @title non-primitive SJF
import matplotlib.pyplot as plt

# ------------------------------------------------------- SJF Function ---------------------------------------------------------
def sjf_non_preemptive_with_arrival(processes):
    # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø­Ø³Ø¨ ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„ ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    original_processes = processes.copy()  # Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„Ø¹Ø±Ø¶ Ù„Ø§Ø­Ù‚Ù‹Ø§
    processes.sort(key=lambda x: x[1]) # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø­Ø³Ø¨ ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„
    n = len(processes)
    waiting_time = [0] * n        #Waiting_time = [0,0,0,0]
    turnaround_time = [0] * n     #Turnaround_time = [0,0,0,0]
    gantt_chart = []
    current_time = 0
    completed = 0
    ready_queue = []
    process_index = 0
    final_order = []  # Ù‚Ø§Ø¦Ù…Ø© Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ

    # Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„ ÙˆÙˆÙ‚Øª Ø§Ù„ØªÙ†ÙÙŠØ°
    while completed < n:
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ÙˆØµÙ„Øª Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        while process_index < n and processes[process_index][1] <= current_time:
            ready_queue.append(processes[process_index])
            process_index += 1


        # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ÙØ§Ø±ØºØ©ØŒ ØªÙ‚Ø¯Ù… Ø§Ù„Ø²Ù…Ù† Ø¥Ù„Ù‰ Ø£Ù‚Ø±Ø¨ Ø¹Ù…Ù„ÙŠØ© Ù‚Ø§Ø¯Ù…Ø©
        if not ready_queue:
            current_time = processes[process_index][1]
            continue


        # Ø§Ø®ØªÙŠØ§Ø± Ø£Ù‚ØµØ± Ø¹Ù…Ù„ÙŠØ© ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        ready_queue.sort(key=lambda x: x[2])      # Sort processes in the ready queue based on Shortest Burst time
        current_process = ready_queue.pop(0)      # pop the first process (previously sorted) from the ready Qeueue to start executing
        name, arrival, burst = current_process    # Split (current_process) Into three Variables (name, arrival, burst).


        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª
        start_time = current_time
        end_time = current_time + burst
        waiting_time[completed] = start_time - arrival
        turnaround_time[completed] = waiting_time[completed] + burst
        gantt_chart.append((name, start_time, end_time))
        final_order.append(current_process)
        current_time = end_time
        completed += 1

    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª
    avg_wtime = sum(waiting_time) / n
    avg_ttime = sum(turnaround_time) / n

    # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°
    print("\nProcess Table:")
    print(f"{'Process':<10}{'Arrival Time':<15}{'Burst Time':<15}{'Waiting Time':<15}{'Turnaround Time':<15}")
    for i, process in enumerate(final_order):
        name, arrival, burst = process
        print(f"{name:<10}{arrival:<15}{burst:<15}{waiting_time[i]:<15}{turnaround_time[i]:<15}")
    print(f"\nAverage Waiting Time: {avg_wtime:.2f}")
    print(f"Average Turnaround Time: {avg_ttime:.2f}")

    # Gantt Chart
    fig, ax = plt.subplots(figsize=(12, 2))

    for p in gantt_chart:
        name, start, end = p
        ax.barh(y=0, width=end - start, left=start, height=0.8, align='center', color='skyblue', edgecolor='black')
        ax.text((start + end) / 2, 0, name, ha='center', va='center', fontsize=12, fontweight='bold')

    # Ø±Ø³Ù… Ø§Ù„Ø£ÙˆÙ‚Ø§Øª (Ø¹Ù„Ù‰ Ù…Ø­ÙˆØ± x Ø£Ø³ÙÙ„ ÙƒÙ„ Ø­Ø¯)
    for p in gantt_chart:
        name, start, end = p
        ax.text(start, -0.6, str(start), ha='center', va='center', fontsize=10)
    # Ø¹Ø±Ø¶ Ù†Ù‡Ø§ÙŠØ© Ø¢Ø®Ø± Ø¹Ù…Ù„ÙŠØ©
    ax.text(gantt_chart[-1][2], -0.6, str(gantt_chart[-1][2]), ha='center', va='center', fontsize=10)

    # ØªÙ†Ø³ÙŠÙ‚Ø§Øª
    ax.set_yticks([])
    ax.set_ylim(-1, 1)
    ax.set_xlim(0, gantt_chart[-1][2] + 1)
    ax.set_xlabel("Time")
    ax.set_title("Gantt Chart - SJF Non-Preemptive with Arrival Time", pad=20)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)

    plt.tight_layout()
    plt.show()

def main_function_4():
    print("Running main function 4")
# ------------------------------------------------------- Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ---------------------------------------------------------
    n = int(input("Enter the number of processes: "))
    processes = []

    use_arrival_time = input("Use arrival times? (yes/no): ").strip().lower()

    for i in range(n):
        if use_arrival_time == "yes":
            at = int(input(f"Enter Arrival Time for P{i+1}: "))
        else:
            at = 0
        bt = int(input(f"Enter Burst Time for P{i+1}: "))
        processes.append([f'P{i+1}', at, bt]) # [["p1",0,5]]

    # Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙÙ†ÙƒØ´Ù†
    sjf_non_preemptive_with_arrival(processes)

# @title First Come, First Served (FCFS)
import matplotlib.pyplot as plt

def main_function_5():
    print("Running main function 5")
    n = int(input("Enter number of processes: "))
    processes = [f'P{i+1}' for i in range(n)]
    burst_times = []

    for i in range(n):
        bt = int(input(f"Enter burst time for {processes[i]}: "))
        burst_times.append(bt)

    start_times = []
    waiting_times = []
    turnaround_times = []

    current_time = 0

    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª
    for i in range(n):
        start_times.append(current_time)
        waiting_times.append(current_time)
        current_time += burst_times[i]
        turnaround_times.append(current_time)

    # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬
    print("\nProcess\tBurst\tWaiting\tTurnaround")
    for i in range(n):
        print(f"{processes[i]}\t{burst_times[i]}\t{waiting_times[i]}\t{turnaround_times[i]}")

    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª
    avg_waiting_time = sum(waiting_times) / n
    avg_turnaround_time = sum(turnaround_times) / n

    print(f"\nAverage Waiting Time: {avg_waiting_time:.2f}")
    print(f"Average Turnaround Time: {avg_turnaround_time:.2f}")

    # Ø±Ø³Ù… Ù…Ø®Ø·Ø· Gantt
    fig, gnt = plt.subplots()
    gnt.set_ylim(0, 50)
    gnt.set_xlim(0, current_time + 1)
    gnt.set_xlabel('Time')
    gnt.set_yticks([])
    gnt.set_title('Gantt Chart - FCFS')

    colors = plt.cm.get_cmap('tab10', n)

    for i in range(n):
        gnt.broken_barh([(start_times[i], burst_times[i])], (10, 10), facecolors=colors(i))
        gnt.text(start_times[i] + burst_times[i]/2, 13, processes[i], ha='center', va='center')
        gnt.text(start_times[i], 8, str(start_times[i]), ha='center')
    gnt.text(start_times[-1] + burst_times[-1], 8, str(start_times[-1] + burst_times[-1]), ha='center')

    plt.show()

