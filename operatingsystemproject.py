# -*- coding: utf-8 -*-
"""OperatingSystemProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_h6iAHoq_-WZ-0-ddKPu3uC_yB-7_6R2

# Operating System Project
"""

# @title Master function

available_functions = {
    "1": main_function_1,
    "2": main_function_2,
    "3": main_function_3,
    "4": main_function_4,
    "5": main_function_5
}

# Ask the user to choose a function to run
selected_function = input("Enter the number from the menu: \n1- Priority\n2- Perimeter SJF\n3- Round Robin\n4- Non-Primitive SJF\n5- First Come, First Served (FCFS)\n")

# Execute the selected function
if selected_function in available_functions:
    available_functions[selected_function]()
else:
    print("Invalid selection. Please choose a number between 1 and 5.")

# @title priority
import matplotlib.pyplot as plt
from tabulate import tabulate

# Priority Ø®ÙˆØ±Ø§Ø²Ù…ÙŠØ©
def priority_scheduling(processes):
    #ØªÙ†Ø¸ÙŠÙ… Ø¹Ù„Ù‰ Ø§Ø³Ø§Ø³ Ø§Ù„Ø§ÙˆÙ„ÙˆÙŠØ©
    processes.sort(key=lambda x: x['priority'])

    print("\nProcess Execution Order based on Priority Scheduling:")
    total_wait_time = 0
    total_turnaround_time = 0
    time_elapsed = 0

    process_table = []  # ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ø¹Ø±Ø¶Ù‡Ø§ Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø¬Ø¯ÙˆÙ„

    process_names = []
    start_times = []
    burst_times = []
    turnaround_times = []

    for process in processes:
        # Ø­Ø³Ø§Ø¨ wait time Ùˆ turnaround time
        wait_time = time_elapsed
        turnaround_time = wait_time + process['burst_time']

        total_wait_time += wait_time
        total_turnaround_time += turnaround_time

        # ØªÙˆØµÙŠÙ„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨Ø±ÙˆØ³ÙŠØ³ Ø§Ù„Ù‰ Ø§Ù„Ø¬Ø¯ÙˆÙ„
        process_table.append([process['name'], process['burst_time'], wait_time, turnaround_time])

        # ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙˆÙ‚Øª Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ…Ø±
        process_names.append(process['name'])
        start_times.append(time_elapsed)
        burst_times.append(process['burst_time'])
        turnaround_times.append(turnaround_time)
        time_elapsed += process['burst_time']

    avg_wait_time = total_wait_time / len(processes)
    avg_turnaround_time = total_turnaround_time / len(processes)

    # Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Ø¬Ø¯ÙˆÙ„
    print(tabulate(process_table, headers=["ğŸ”¤ Process", "â²ï¸ Burst Time   ", "â±ï¸ Waiting Time   ", "â³ Turnaround Time   "], tablefmt="grid"))
    print(f"\nğŸ•’ Average Waiting Time: {avg_wait_time:.2f}")
    print(f"â³ Average Turnaround Time: {avg_turnaround_time:.2f}")

    # ØªØµÙˆÙŠØ± Ø§Ù„Ø¨Ø±ÙˆØ³ÙŠØ³ Ø¹Ù„Ù‰ Ø´ÙƒÙ„ Gantt-Chart
    plt.figure(figsize=(14, 2))

    # Ø¹Ø±Ø¶ Gantt-Chart
    for i, process in enumerate(process_names):
        plt.barh(0.4, burst_times[i], left=start_times[i], color='lightblue', edgecolor='black', height=0.8)
        plt.text(start_times[i] + burst_times[i] / 2, 0.4, process, ha='center', va='center', color='black', fontsize=30)
    # Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙˆÙ‚Øª ÙÙŠ Ø§Ù„Ø´ÙƒÙ„
    for start, burst in zip(start_times, burst_times):
        plt.text(start, -0.2, f"{start}", ha='center', va='center', fontsize=25)
    plt.text(start_times[-1] + burst_times[-1], -0.2, f"{start_times[-1] + burst_times[-1]}", ha='center', va='center', fontsize=25)

    plt.yticks([])
    plt.xticks([])
    plt.title('Gantt Chart - Priority Scheduling')
    plt.tight_layout()
    plt.show()

# Main function
def main_function_1():
    print("Running main function 1")

    processes = []
    num_processes = int(input(" \"â­ priority scheduling Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø§Ù„Ø§ÙˆÙ„ÙˆÙŠØ© â­\" \n \n Enter the number of processes: "))

    for i in range(num_processes):
        name = f"P{i + 1}"
        print(f"\nProcess {name}:")
        priority = int(input(f"ğŸ”¢ Enter priority : "))
        burst_time = int(input(f"â²ï¸ Enter burst time : "))
        processes.append({'name': name, 'priority': priority, 'burst_time': burst_time})

    priority_scheduling(processes)

# @title primitive SJF
import matplotlib.pyplot as plt

# === Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª ===
def find_times(n, at, bt):
    rt = bt.copy()
    wt = [0] * n
    tat = [0] * n
    rt_time = [-1] * n  # ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
    complete = 0
    t = 0
    minm = float('inf')
    shortest = 0
    check = False

    while complete != n:
        for j in range(n):
            if at[j] <= t and rt[j] < minm and rt[j] > 0:
                minm = rt[j]
                shortest = j
                check = True

        if not check:
            t += 1
            continue

        # Ø­Ø³Ø§Ø¨ ÙˆÙ‚Øª Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø© Ø£ÙˆÙ„ Ù…Ø±Ø© ÙÙ‚Ø·
        if rt_time[shortest] == -1:
            rt_time[shortest] = t - at[shortest]

        rt[shortest] -= 1
        minm = rt[shortest]
        if minm == 0:
            minm = float('inf')

        if rt[shortest] == 0:
            complete += 1
            check = False
            finish_time = t + 1
            wt[shortest] = finish_time - bt[shortest] - at[shortest]
            if wt[shortest] < 0:
                wt[shortest] = 0

        t += 1

    for i in range(n):
        tat[i] = bt[i] + wt[i]

    return wt, tat, rt_time

# === ØªÙˆÙ„ÙŠØ¯ Ù…Ø®Ø·Ø· Ø¬Ø§Ù†Øª ===
def srtf_schedule(at, bt):
    n = len(bt)
    rt = bt.copy()
    complete = 0
    t = 0
    gantt_chart = []
    minm = float('inf')
    shortest = 0
    check = False

    while complete != n:
        for j in range(n):
            if at[j] <= t and rt[j] < minm and rt[j] > 0:
                minm = rt[j]
                shortest = j
                check = True

        if not check:
            gantt_chart.append("Idle")
            t += 1
            continue

        rt[shortest] -= 1
        gantt_chart.append(f"P{shortest + 1}")

        if rt[shortest] == 0:
            complete += 1
            minm = float('inf')
            check = False

        t += 1

    return gantt_chart

def main_function_2():
    print("Running main function 2")
    # Ø¥Ø¯Ø®Ø§Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
    n = int(input("Ø£Ø¯Ø®Ù„ Ø¹Ø¯Ø¯ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª: "))

    # Ø¥Ø¯Ø®Ø§Ù„ Ø£ÙˆÙ‚Ø§Øª Ø§Ù„ÙˆØµÙˆÙ„ ÙˆØ§Ù„ØªÙ†ÙÙŠØ°
    processes = [f'P{i+1}' for i in range(n)]
    arrival_time = []
    burst_time = []

    for i in range(n):
        at = int(input(f"ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ø¹Ù…Ù„ÙŠØ© {processes[i]}: "))
        bt = int(input(f"ÙˆÙ‚Øª Ø§Ù„ØªÙ†ÙÙŠØ° (Burst Time) Ù„Ù„Ø¹Ù…Ù„ÙŠØ© {processes[i]}: "))
        arrival_time.append(at)
        burst_time.append(bt)

    # ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª
    wt, tat, rt_time = find_times(n, arrival_time, burst_time)
    gantt = srtf_schedule(arrival_time, burst_time)

    # Ø¶ØºØ· Ø§Ù„ÙØªØ±Ø§Øª ÙÙŠ Ù…Ø®Ø·Ø· Ø¬Ø§Ù†Øª
    compressed = []
    if gantt:
        current = gantt[0]
        start = 0
        for i in range(1, len(gantt)):
            if gantt[i] != current:
                compressed.append((current, start, i))
                current = gantt[i]
                start = i
        compressed.append((current, start, len(gantt)))

    # === Ø§Ù„Ø±Ø³Ù… ===
    fig, axs = plt.subplots(2, 1, figsize=(12, 5), gridspec_kw={'height_ratios': [1, 2]})
    axs[0].axis('off')
    columns = ['Process', 'Arrival Time', 'Burst Time', 'Waiting Time', 'Turnaround Time', 'Response Time']
    cell_text = [[processes[i], arrival_time[i], burst_time[i], wt[i], tat[i], rt_time[i]] for i in range(n)]
    table = axs[0].table(cellText=cell_text, colLabels=columns, loc='center', cellLoc='center')
    table.scale(1, 2)

    for task, start, end in compressed:
        axs[1].barh(0, end - start, left=start, edgecolor='black')
        axs[1].text((start + end) / 2, 0, task, va='center', ha='center', color='white', fontsize=9)

    axs[1].set_xlim(0, len(gantt))
    axs[1].set_yticks([])
    axs[1].set_xticks(range(len(gantt)+1))
    axs[1].set_title('Gantt Chart - SJF Preemptive (SRTF)')
    axs[1].grid(axis='x')
    plt.tight_layout()
    plt.show()

# @title Round Robin (RR)
import matplotlib.pyplot as plt
import pandas as pd

class RoundRobinScheduler:
    def __init__(self, processes, burst_times, quantum, arrival_times=None):
        self.processes = processes
        self.burst_times = burst_times
        self.quantum = quantum
        self.arrival_times = arrival_times if arrival_times is not None else [0] * len(processes)

    def schedule(self):
        if set(self.arrival_times) == {0}:
            return self.schedule_no_arrival()
        else:
            return self.schedule_with_arrival()

    def schedule_no_arrival(self):
        n = len(self.processes)
        remaining_bt = self.burst_times.copy()
        waiting = [0] * n
        turnaround = [0] * n
        response = [-1] * n
        timeline = []
        current_time = 0

        while True:
            done = True
            for i in range(n):
                if remaining_bt[i] > 0:
                    done = False
                    if response[i] == -1:
                        response[i] = current_time
                    start = current_time
                    exec_time = min(remaining_bt[i], self.quantum)
                    current_time += exec_time
                    remaining_bt[i] -= exec_time
                    end = current_time
                    timeline.append((self.processes[i], start, end))
                    if remaining_bt[i] == 0:
                        turnaround[i] = current_time
                        waiting[i] = turnaround[i] - self.burst_times[i]
            if done:
                break

        return waiting, turnaround, timeline, response

    def schedule_with_arrival(self):
        n = len(self.processes)
        remaining_bt = self.burst_times.copy()
        waiting = [0] * n
        turnaround = [0] * n
        response = [-1] * n
        timeline = []
        current_time = 0
        ready_queue = []
        completed = []

        while len(completed) < n:
            for i in range(n):
                if self.arrival_times[i] <= current_time and i not in ready_queue and i not in completed:
                    ready_queue.append(i)

            if not ready_queue:
                next_time = min([self.arrival_times[i] for i in range(n) if i not in completed])
                timeline.append(("IDLE", current_time, next_time))
                current_time = next_time
                continue

            process_idx = ready_queue.pop(0)
            if response[process_idx] == -1:
                response[process_idx] = current_time - self.arrival_times[process_idx]
            start = current_time
            exec_time = min(remaining_bt[process_idx], self.quantum)
            current_time += exec_time
            remaining_bt[process_idx] -= exec_time
            end = current_time
            timeline.append((self.processes[process_idx], start, end))

            if remaining_bt[process_idx] == 0:
                completed.append(process_idx)
                turnaround[process_idx] = current_time - self.arrival_times[process_idx]
                waiting[process_idx] = turnaround[process_idx] - self.burst_times[process_idx]
            else:
                ready_queue.append(process_idx)

        return waiting, turnaround, timeline, response

    def print_results(self, waiting, turnaround, response):
        df = pd.DataFrame({
            "Process": self.processes,
            "Arrival Time": self.arrival_times,
            "Burst Time": self.burst_times,
            "Waiting Time": waiting,
            "Turnaround Time": turnaround,
            "Response Time": response
        })

        print("\n", df.to_string(index=False))
        print(f"\nAverage Waiting Time: {sum(waiting)/len(waiting):.2f}")
        print(f"Average Turnaround Time: {sum(turnaround)/len(turnaround):.2f}")
        print(f"Average Response Time: {sum(response)/len(response):.2f}")

    def plot_gantt_chart(self, timeline):
        fig, ax = plt.subplots(figsize=(10, 2))
        for pid, start, end in timeline:
            ax.barh(0, end-start, left=start, color="skyblue", edgecolor='black')
            ax.text((start+end)/2, 0, pid, ha='center', va='center', fontsize=9)
            ax.text(start, 0.3, str(start), ha='center', fontsize=8)
            ax.text(end, 0.3, str(end), ha='center', fontsize=8)

        plt.title('Gantt Chart - Round Robin')
        plt.xlabel('Time')
        plt.yticks([])
        plt.tight_layout()
        plt.show()

def main_function_3():
    print("Running main function 3")
    print("Round Robin Scheduler")
    has_arrival = input("Do you have arrival times? (y/n): ").lower() == 'y'
    n = int(input("Enter number of processes: "))
    processes = [f"P{i+1}" for i in range(n)]
    bursts, arrivals = [], []

    for p in processes:
        bursts.append(int(input(f"Enter Burst Time for {p}: ")))

    if has_arrival:
        for p in processes:
            arrivals.append(int(input(f"Enter Arrival Time for {p}: ")))
    else:
        arrivals = None

    quantum = int(input("Enter Time Quantum: "))
    scheduler = RoundRobinScheduler(processes, bursts, quantum, arrivals)
    waiting, turnaround, timeline, response = scheduler.schedule()
    scheduler.print_results(waiting, turnaround, response)
    scheduler.plot_gantt_chart(timeline)

# @title non-primitive SJF
import matplotlib.pyplot as plt

# ------------------------------------------------------- SJF Function ---------------------------------------------------------
def sjf_non_preemptive_with_arrival(processes):
    # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø­Ø³Ø¨ ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„ ÙÙ‚Ø· ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
    original_processes = processes.copy()  # Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø£ØµÙ„ÙŠ Ù„Ù„Ø¹Ø±Ø¶ Ù„Ø§Ø­Ù‚Ù‹Ø§
    processes.sort(key=lambda x: x[1]) # ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø­Ø³Ø¨ ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„
    n = len(processes)
    waiting_time = [0] * n        #Waiting_time = [0,0,0,0]
    turnaround_time = [0] * n     #Turnaround_time = [0,0,0,0]
    gantt_chart = []
    current_time = 0
    completed = 0
    ready_queue = []
    process_index = 0
    final_order = []  # Ù‚Ø§Ø¦Ù…Ø© Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ

    # Ù…Ø¹Ø§Ù„Ø¬Ø© ÙƒÙ„ Ø¹Ù…Ù„ÙŠØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ ÙˆÙ‚Øª Ø§Ù„ÙˆØµÙˆÙ„ ÙˆÙˆÙ‚Øª Ø§Ù„ØªÙ†ÙÙŠØ°
    while completed < n:
        # Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„ØªÙŠ ÙˆØµÙ„Øª Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        while process_index < n and processes[process_index][1] <= current_time:
            ready_queue.append(processes[process_index])
            process_index += 1


        # Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø± ÙØ§Ø±ØºØ©ØŒ ØªÙ‚Ø¯Ù… Ø§Ù„Ø²Ù…Ù† Ø¥Ù„Ù‰ Ø£Ù‚Ø±Ø¨ Ø¹Ù…Ù„ÙŠØ© Ù‚Ø§Ø¯Ù…Ø©
        if not ready_queue:
            current_time = processes[process_index][1]
            continue


        # Ø§Ø®ØªÙŠØ§Ø± Ø£Ù‚ØµØ± Ø¹Ù…Ù„ÙŠØ© ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±
        ready_queue.sort(key=lambda x: x[2])      # Sort processes in the ready queue based on Shortest Burst time
        current_process = ready_queue.pop(0)      # pop the first process (previously sorted) from the ready Qeueue to start executing
        name, arrival, burst = current_process    # Split (current_process) Into three Variables (name, arrival, burst).


        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª
        start_time = current_time
        end_time = current_time + burst
        waiting_time[completed] = start_time - arrival
        turnaround_time[completed] = waiting_time[completed] + burst
        gantt_chart.append((name, start_time, end_time))
        final_order.append(current_process)
        current_time = end_time
        completed += 1

    # Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…ØªÙˆØ³Ø·Ø§Øª
    avg_wtime = sum(waiting_time) / n
    avg_ttime = sum(turnaround_time) / n

    # Ø·Ø¨Ø§Ø¹Ø© Ø§Ù„Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ù„ØªØ±ØªÙŠØ¨ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ†ÙÙŠØ°
    print("\nProcess Table:")
    print(f"{'Process':<10}{'Arrival Time':<15}{'Burst Time':<15}{'Waiting Time':<15}{'Turnaround Time':<15}")
    for i, process in enumerate(final_order):
        name, arrival, burst = process
        print(f"{name:<10}{arrival:<15}{burst:<15}{waiting_time[i]:<15}{turnaround_time[i]:<15}")
    print(f"\nAverage Waiting Time: {avg_wtime:.2f}")
    print(f"Average Turnaround Time: {avg_ttime:.2f}")

    # Gantt Chart
    fig, ax = plt.subplots(figsize=(12, 2))

    for p in gantt_chart:
        name, start, end = p
        ax.barh(y=0, width=end - start, left=start, height=0.8, align='center', color='skyblue', edgecolor='black')
        ax.text((start + end) / 2, 0, name, ha='center', va='center', fontsize=12, fontweight='bold')

    # Ø±Ø³Ù… Ø§Ù„Ø£ÙˆÙ‚Ø§Øª (Ø¹Ù„Ù‰ Ù…Ø­ÙˆØ± x Ø£Ø³ÙÙ„ ÙƒÙ„ Ø­Ø¯)
    for p in gantt_chart:
        name, start, end = p
        ax.text(start, -0.6, str(start), ha='center', va='center', fontsize=10)
    # Ø¹Ø±Ø¶ Ù†Ù‡Ø§ÙŠØ© Ø¢Ø®Ø± Ø¹Ù…Ù„ÙŠØ©
    ax.text(gantt_chart[-1][2], -0.6, str(gantt_chart[-1][2]), ha='center', va='center', fontsize=10)

    # ØªÙ†Ø³ÙŠÙ‚Ø§Øª
    ax.set_yticks([])
    ax.set_ylim(-1, 1)
    ax.set_xlim(0, gantt_chart[-1][2] + 1)
    ax.set_xlabel("Time")
    ax.set_title("Gantt Chart - SJF Non-Preemptive with Arrival Time", pad=20)
    ax.spines['top'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)

    plt.tight_layout()
    plt.show()

def main_function_4():
    print("Running main function 4")
# ------------------------------------------------------- Ø§Ø³ØªÙ‚Ø¨Ø§Ù„ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ---------------------------------------------------------
    n = int(input("Enter the number of processes: "))
    processes = []

    use_arrival_time = input("Use arrival times? (yes/no): ").strip().lower()

    for i in range(n):
        if use_arrival_time == "yes":
            at = int(input(f"Enter Arrival Time for P{i+1}: "))
        else:
            at = 0
        bt = int(input(f"Enter Burst Time for P{i+1}: "))
        processes.append([f'P{i+1}', at, bt])

    # Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø§Ù„ÙÙ†ÙƒØ´Ù†
    sjf_non_preemptive_with_arrival(processes)

# @title First Come, First Served (FCFS)
import matplotlib.pyplot as plt

def main_function_5():
    print("Running main function 5")
    n = int(input("Enter number of processes: "))
    processes = [f'P{i+1}' for i in range(n)]
    burst_times = []
    arrival_times = []

    # Input arrival and burst times
    for i in range(n):
        at = int(input(f"Enter arrival time for {processes[i]}: "))
        bt = int(input(f"Enter burst time for {processes[i]}: "))
        arrival_times.append(at)
        burst_times.append(bt)

    # Sort processes based on arrival times
    info = sorted(zip(processes, arrival_times, burst_times), key=lambda x: x[1])
    processes, arrival_times, burst_times = zip(*info)

    start_times = []
    waiting_times = []
    turnaround_times = []

    current_time = 0

    # Calculate start times, waiting times, and turnaround times
    for i in range(n):
        if current_time < arrival_times[i]:
            current_time = arrival_times[i]
        start_times.append(current_time)
        waiting_times.append(current_time - arrival_times[i])
        current_time += burst_times[i]
        turnaround_times.append(current_time - arrival_times[i])

    # Print results
    print("\nProcess\tArrival\tBurst\tWaiting\tTurnaround")
    for i in range(n):
        print(f"{processes[i]}\t{arrival_times[i]}\t{burst_times[i]}\t{waiting_times[i]}\t{turnaround_times[i]}")

    # Plot Gantt chart
    fig, gnt = plt.subplots()
    gnt.set_ylim(0, 50)
    gnt.set_xlim(0, max(start_times[i] + burst_times[i] for i in range(n)) + 1)
    gnt.set_xlabel('Time')
    gnt.set_yticks([])
    gnt.set_title('Gantt Chart - FCFS with Arrival Time')

    colors = plt.cm.get_cmap('tab10', n)

    for i in range(n):
        gnt.broken_barh([(start_times[i], burst_times[i])], (10, 10), facecolors=colors(i))
        gnt.text(start_times[i] + burst_times[i]/2, 13, processes[i], ha='center', va='center')
        gnt.text(start_times[i], 8, str(start_times[i]), ha='center')
    gnt.text(start_times[-1] + burst_times[-1], 8, str(start_times[-1] + burst_times[-1]), ha='center')

    plt.show()

# Ensure the main function runs when the script is executed